package main

import (
	"context"
	"encoding/json"
	"fmt"
	"image/color"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync/atomic"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
	"github.com/lrstanley/go-ytdlp"
)

/* -------------------- Custom Progress Bar -------------------- */

type CustomProgressBar struct {
	widget.BaseWidget
	value float64 // 0.0 to 1.0
}

func NewCustomProgressBar() *CustomProgressBar {
	p := &CustomProgressBar{}
	p.ExtendBaseWidget(p)
	return p
}

func (p *CustomProgressBar) SetValue(v float64) {
	if v < 0 {
		v = 0
	}
	if v > 1 {
		v = 1
	}
	if p.value != v {
		p.value = v
		p.Refresh()
	}
}

func (p *CustomProgressBar) CreateRenderer() fyne.WidgetRenderer {
	background := canvas.NewRectangle(color.NRGBA{R: 40, G: 40, B: 50, A: 255}) // Dark background
	background.CornerRadius = 10

	fill := canvas.NewRectangle(color.NRGBA{R: 0, G: 140, B: 255, A: 255}) // Solid bright blue fill
	fill.CornerRadius = 10

	// Optional subtle inner shadow/overlay for depth (comment out if not wanted)
	overlay := canvas.NewRectangle(color.NRGBA{R: 0, G: 0, B: 0, A: 30})
	overlay.CornerRadius = 10

	percentageText := canvas.NewText("0%", color.White)
	percentageText.TextSize = 15
	percentageText.Alignment = fyne.TextAlignCenter

	// Stack: background -> fill -> overlay -> centered text
	stack := container.NewStack(background, fill, overlay)
	content := container.NewStack(stack, container.NewCenter(percentageText))

	return &customProgressRenderer{
		container:      content,
		background:     background,
		fill:           fill,
		overlay:        overlay,
		percentageText: percentageText,
		progress:       p,
	}
}

type customProgressRenderer struct {
	container      *fyne.Container
	background     *canvas.Rectangle
	fill           *canvas.Rectangle
	overlay        *canvas.Rectangle
	percentageText *canvas.Text
	progress       *CustomProgressBar
}

func (r *customProgressRenderer) Layout(size fyne.Size) {
	r.container.Resize(size)

	// Full background and overlay
	r.background.Resize(size)
	r.overlay.Resize(size)

	// Fill based on progress
	fillWidth := size.Width * float32(r.progress.value)
	r.fill.Resize(fyne.NewSize(fillWidth, size.Height))

	// Update percentage text
	r.percentageText.Text = fmt.Sprintf("%.0f%%", r.progress.value*100)
	r.percentageText.Refresh()
}

func (r *customProgressRenderer) MinSize() fyne.Size {
	return fyne.NewSize(300, 40)
}

func (r *customProgressRenderer) Refresh() {
	r.Layout(r.container.Size())
}

func (r *customProgressRenderer) BackgroundColor() color.Color {
	return color.Transparent
}

func (r *customProgressRenderer) Objects() []fyne.CanvasObject {
	return []fyne.CanvasObject{r.container}
}

func (r *customProgressRenderer) Destroy() {}

/* -------------------- Dependency Check -------------------- */

func checkAndInstallDeps(w fyne.Window) error {
	if _, err := exec.LookPath("ffmpeg"); err == nil {
		if _, err := exec.LookPath("ffprobe"); err == nil {
			ytdlp.MustInstall(context.Background(), nil)
			return nil
		}
	}

	done := make(chan error, 1)

	confirm := dialog.NewConfirm(
		"Install Required Tools",
		"Predator requires ffmpeg and ffprobe for merging video+audio and extracting audio.\n\n"+
			"They are not detected on your system.\n\n"+
			"We can automatically download open-source bundled versions (yt-dlp + ffmpeg + ffprobe) and cache them locally.\n\n"+
			"Do you want to continue? (Recommended)",
		func(ok bool) {
			if !ok {
				done <- fmt.Errorf("user declined bundled dependency installation")
				return
			}

			bar := widget.NewProgressBarInfinite()
			label := widget.NewLabel("Downloading yt-dlp, ffmpeg & ffprobe…\nThis may take a moment on first run.")
			content := container.NewVBox(label, bar)

			progressDialog := dialog.NewCustomWithoutButtons("Installing Dependencies", content, w)
			progressDialog.Show()

			go func() {
				defer progressDialog.Hide()

				_, err := ytdlp.Install(context.Background(), nil)
				if err != nil {
					done <- fmt.Errorf("failed to install dependencies: %w", err)
					return
				}
				done <- nil
			}()
		},
		w,
	)

	confirm.SetDismissText("No")
	confirm.SetConfirmText("Yes, Install")
	confirm.Show()

	return <-done
}

const prefOutputDir = "output_dir"

/* -------------------- Helpers -------------------- */

func formatBytes(b float64) string {
	const unit = 1024
	if b < unit {
		return fmt.Sprintf("%.0f B", b)
	}
	div, exp := float64(unit), 0
	for n := b / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %ciB", b/div, "KMGT"[exp])
}

func formatETA(d time.Duration) string {
	s := int64(d.Seconds())
	h := s / 3600
	m := (s % 3600) / 60
	sec := s % 60
	if h > 0 {
		return fmt.Sprintf("%02d:%02d:%02d", h, m, sec)
	}
	return fmt.Sprintf("%02d:%02d", m, sec)
}

func formatSpeed(speed float64) string {
	return formatBytes(speed) + "/s"
}

/* -------------------- Main -------------------- */

func main() {
	a := app.NewWithID("Predator")
	w := a.NewWindow("Predator")
	w.Resize(fyne.NewSize(560, 520))
	prefs := a.Preferences()

	// Set app icon if available
	if logo, err := os.ReadFile("logov4.png"); err == nil {
		appIcon := fyne.NewStaticResource("logov4.png", logo)
		w.SetIcon(appIcon)
	}

	/* -------------------- Dependency Check -------------------- */
	go func() {
		err := checkAndInstallDeps(w)
		if err != nil {
			fyne.Do(func() {
				var msg string
				if strings.Contains(err.Error(), "user declined") {
					msg = "Dependency installation was declined.\n\nVideo downloads and audio extraction will not work properly."
				} else {
					msg = fmt.Sprintf("Failed to install required dependencies (yt-dlp/ffmpeg):\n%s\n\nSome features will be limited.", err)
				}
				dialog.ShowError(fmt.Errorf(msg), w)
			})
		}
	}()

	/* -------------------- UI Components -------------------- */
	urlEntry := widget.NewEntry()
	urlEntry.SetPlaceHolder("Paste YouTube URL here")

	downloadType := widget.NewRadioGroup([]string{"Video", "Audio"}, nil)
	downloadType.SetSelected("Video")

	resolutions := []string{"144p", "240p", "360p", "480p", "720p", "1080p", "1440p", "2160p", "best"}
	resSelect := widget.NewSelect(nil, nil)
	resSelect.Disable()

	audioFormats := []string{"mp3", "m4a", "opus", "wav"}
	audioSelect := widget.NewSelect(audioFormats, nil)
	audioSelect.SetSelected("mp3")
	audioSelect.Disable()

	downloadType.OnChanged = func(s string) {
		if s == "Video" {
			resSelect.Enable()
			audioSelect.Disable()
		} else {
			resSelect.Disable()
			audioSelect.Enable()
		}
	}

	progressBar := NewCustomProgressBar()
	statusLabel := widget.NewLabel("")
	speedLabel := widget.NewLabel("")

	downloadBtn := widget.NewButton("Download", nil)
	downloadBtn.Disable()

	cancelBtn := widget.NewButton("Cancel", nil)
	cancelBtn.Disable()

	titleLabel := widget.NewLabel("")
	titleLabel.Wrapping = fyne.TextWrapWord

	/* -------------------- Output Directory -------------------- */
	outputDir := prefs.String(prefOutputDir)
	outputDirLabel := widget.NewLabel("")

	updateOutputUI := func() {
		if outputDir == "" {
			outputDirLabel.SetText("Download location not set")
		} else {
			outputDirLabel.SetText("Download Location: " + outputDir)
		}
	}

	selectDirectory := func() {
		dialog.NewFolderOpen(func(uri fyne.ListableURI, err error) {
			if err != nil || uri == nil {
				return
			}
			outputDir = uri.Path()
			prefs.SetString(prefOutputDir, outputDir)
			updateOutputUI()
		}, w).Show()
	}

	if outputDir == "" {
		dialog.ShowInformation("Select Download Location", "Please select a download folder.", w)
		selectDirectory()
	}
	updateOutputUI()

	changeDirBtn := widget.NewButton("Change Download Location", selectDirectory)

	/* -------------------- Fetch Video Info -------------------- */
	var fetchTimer *time.Timer
	var fetching int32

	urlEntry.OnChanged = func(text string) {
		text = strings.TrimSpace(text)
		if fetchTimer != nil {
			fetchTimer.Stop()
		}
		if text == "" {
			return
		}

		fetchTimer = time.AfterFunc(600*time.Millisecond, func() {
			if atomic.LoadInt32(&fetching) == 1 {
				return
			}
			atomic.StoreInt32(&fetching, 1)

			fyne.Do(func() {
				statusLabel.SetText("Fetching video info...")
				resSelect.Disable()
				downloadBtn.Disable()
			})

			go fetchVideoInfo(text, resolutions, resSelect, statusLabel, titleLabel, downloadBtn, &fetching)
		})
	}

	/* -------------------- Download Logic -------------------- */
	var cancelFunc context.CancelFunc
	var downloading int32

	downloadBtn.OnTapped = func() {
		if atomic.LoadInt32(&downloading) == 1 {
			return
		}

		url := strings.TrimSpace(urlEntry.Text)
		if url == "" || outputDir == "" {
			return
		}

		ctx, cancel := context.WithCancel(context.Background())
		cancelFunc = cancel
		atomic.StoreInt32(&downloading, 1)

		progressBar.SetValue(0)
		statusLabel.SetText("Starting download...")
		speedLabel.SetText("")
		cancelBtn.Enable()
		downloadBtn.Disable()

		go func() {
			defer atomic.StoreInt32(&downloading, 0)

			var lastDownloaded int
			var lastTime time.Time = time.Now()
			var smoothedSpeed float64

			updateProgress := func(p ytdlp.ProgressUpdate) {
				if p.Status != "downloading" {
					return
				}

				now := time.Now()
				elapsed := now.Sub(lastTime).Seconds()
				var speed float64
				if elapsed > 0 {
					speed = float64(p.DownloadedBytes-lastDownloaded) / elapsed
				}

				const alpha = 0.2
				if smoothedSpeed == 0 {
					smoothedSpeed = speed
				} else {
					smoothedSpeed = alpha*speed + (1-alpha)*smoothedSpeed
				}

				fyne.Do(func() {
					progressBar.SetValue(p.Percent() / 100)

					if p.Percent() >= 100 {
						statusLabel.SetText("Processing… (merging)")
						speedLabel.SetText("")
						return
					}

					statusLabel.SetText(fmt.Sprintf("Downloading… %.1f%%", p.Percent()))
					displaySpeed := smoothedSpeed
					if displaySpeed < 0 {
						displaySpeed = 0
					}
					speedLabel.SetText(fmt.Sprintf(
						"Speed: %s | ETA: %s",
						formatSpeed(displaySpeed),
						formatETA(p.ETA()),
					))
				})

				lastDownloaded = p.DownloadedBytes
				lastTime = now
			}

			var err error
			var format string

			if downloadType.Selected == "Video" {
				selected := strings.Split(resSelect.Selected, " ")[0]
				res := strings.TrimSuffix(selected, "p")

				if selected != "best" {
					format = fmt.Sprintf(
						"bestvideo[height<=%s][ext=mp4]+bestaudio[ext=m4a]/"+
							"bestvideo[height<=%s]+bestaudio/best[height<=%s]",
						res, res, res,
					)
				} else {
					format = "bestvideo[vcodec^=avc1]+bestaudio/bestvideo[vcodec^=vp9]+bestaudio/bestvideo[vcodec^=av01]+bestaudio/bestvideo+bestaudio/best"
				}

				_, err = ytdlp.New().
					Format(format).
					NoKeepVideo().
					NoKeepFragments().
					Output(filepath.Join(outputDir, "%(title)s [%(id)s] (%(resolution)s).%(ext)s")).
					ProgressFunc(200*time.Millisecond, updateProgress).
					Run(ctx, url)

			} else {
				_, err = ytdlp.New().
					ExtractAudio().
					AudioFormat(audioSelect.Selected).
					Output(filepath.Join(outputDir, "%(title)s [%(id)s].%(ext)s")).
					ProgressFunc(200*time.Millisecond, updateProgress).
					Run(ctx, url)
			}

			fyne.Do(func() {
				cancelBtn.Disable()
				downloadBtn.Enable()
				speedLabel.SetText("")

				if err != nil {
					if ctx.Err() == context.Canceled {
						statusLabel.SetText("Download canceled")
					} else {
						log.Println("Download error:", err)
						statusLabel.SetText("Download failed")
					}
					progressBar.SetValue(0)
				} else {
					progressBar.SetValue(1)
					statusLabel.SetText("Download completed ✓")
				}
			})
		}()
	}

	cancelBtn.OnTapped = func() {
		if cancelFunc != nil {
			cancelFunc()
		}
	}

	/* -------------------- Layout -------------------- */
	content := container.NewVBox(
		widget.NewLabel("YouTube URL"),
		urlEntry,
		titleLabel,
		downloadType,
		container.NewGridWithColumns(2, resSelect, audioSelect),
		widget.NewSeparator(),
		outputDirLabel,
		changeDirBtn,
		widget.NewSeparator(),
		container.NewHBox(downloadBtn, cancelBtn),
		statusLabel,
		speedLabel,
		progressBar,
	)

	w.SetContent(container.NewVScroll(content))
	w.CenterOnScreen()
	w.ShowAndRun()
}

/* -------------------- Fetch Video Info -------------------- */

func fetchVideoInfo(
	url string,
	resolutions []string,
	resSelect *widget.Select,
	statusLabel *widget.Label,
	titleLabel *widget.Label,
	downloadBtn *widget.Button,
	fetching *int32,
) {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	result, err := ytdlp.New().DumpJSON().Run(ctx, url)

	fyne.Do(func() {
		defer atomic.StoreInt32(fetching, 0)

		if err != nil {
			statusLabel.SetText("Failed to fetch info: " + err.Error())
			return
		}

		var info struct {
			Title   string `json:"title"`
			Formats []struct {
				Height         *int   `json:"height"`
				Filesize       *int64 `json:"filesize"`
				FilesizeApprox *int64 `json:"filesize_approx"`
				Vcodec         string `json:"vcodec"`
			} `json:"formats"`
		}

		if err := json.Unmarshal([]byte(result.Stdout), &info); err != nil {
			statusLabel.SetText("Failed to parse info")
			return
		}

		titleLabel.SetText("Title: " + info.Title)

		resMap := make(map[string]string)
		for _, f := range info.Formats {
			if f.Vcodec != "none" && f.Height != nil {
				res := fmt.Sprintf("%dp", *f.Height)
				if f.Filesize != nil {
					resMap[res] = formatBytes(float64(*f.Filesize))
				} else if f.FilesizeApprox != nil {
					resMap[res] = "~" + formatBytes(float64(*f.FilesizeApprox))
				}
			}
		}

		opts := []string{}
		for _, r := range resolutions {
			size := "Unknown"
			if s, ok := resMap[r]; ok {
				size = s
			}
			opts = append(opts, fmt.Sprintf("%s (%s)", r, size))
		}

		resSelect.Options = opts
		if len(opts) > 0 {
			resSelect.SetSelected(opts[len(opts)-1]) // default to best
		}
		resSelect.Enable()
		downloadBtn.Enable()
		statusLabel.SetText("Ready to download")
	})
}
